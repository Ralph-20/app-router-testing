# Plan 03: Data Cache Demo

**Date:** 2025-11-10
**Goal:** Demonstrate Next.js Data Cache (fetch caching) with tags and revalidation strategies

---

## Overview

Data Cache is a **server-side persistent cache** for `fetch()` responses that persists across requests and deployments.

**Key Characteristics (Next.js 16):**
- `fetch` is **NOT cached by default** (changed from v14)
- Opt-in via `{ cache: 'force-cache' }`
- Can set time-based revalidation via `{ next: { revalidate: seconds } }`
- Can tag via `{ next: { tags: ['tag-name'] } }`
- Invalidate with `revalidateTag()` or `revalidatePath()`
- Persists until revalidated or redeployed

**This demo will:**
1. Show cached vs uncached fetch behavior with timestamps
2. Demonstrate cache tags for targeted invalidation
3. Compare time-based vs on-demand revalidation
4. Provide buttons to trigger revalidation
5. Visualize stale-while-revalidate behavior

---

## Implementation Steps

### Step 1: Create Data Cache Page

**Location:** `my-app/app/(dashboard)/data-cache/page.tsx`

**Action:** Main page showing cached and uncached fetches side-by-side

```typescript
import { Suspense } from 'react';
import { RevalidateButton } from './components/RevalidateButton';

// This page demonstrates Next.js Data Cache
// Compares cached vs uncached fetch behavior
export default function DataCachePage() {
  return (
    <div className="max-w-6xl mx-auto space-y-8">
      {/* Explanation */}
      <section>
        <h2 className="text-3xl font-bold mb-4">Data Cache (fetch caching)</h2>
        <div className="p-6 bg-blue-50 dark:bg-blue-950 border border-blue-200 dark:border-blue-800 rounded-lg">
          <h3 className="font-semibold mb-2">What is Data Cache?</h3>
          <p className="text-sm text-gray-700 dark:text-gray-300 mb-3">
            Server-side persistent cache for <code className="px-1 py-0.5 bg-gray-200 dark:bg-gray-800 rounded">fetch()</code> responses.
            In Next.js 16, fetch is <strong>NOT cached by default</strong> - must opt-in.
          </p>
          <ul className="text-sm text-gray-600 dark:text-gray-400 list-disc list-inside space-y-1">
            <li>Scope: Server-side (all users share same cache)</li>
            <li>Duration: Until revalidated or redeployed</li>
            <li>Opt-in: {`{ cache: 'force-cache' }`} or {`{ next: { revalidate: seconds } }`}</li>
            <li>Invalidation: revalidateTag(), revalidatePath(), or time-based</li>
          </ul>
        </div>
      </section>

      {/* Side-by-side comparison */}
      <section>
        <h3 className="text-xl font-semibold mb-4">Comparison: Cached vs Uncached</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Uncached fetch */}
          <div className="space-y-4">
            <h4 className="font-semibold text-lg">Uncached (default)</h4>
            <Suspense fallback={<LoadingCard />}>
              <UncachedPostCard />
            </Suspense>
          </div>

          {/* Cached fetch */}
          <div className="space-y-4">
            <h4 className="font-semibold text-lg">Cached (force-cache)</h4>
            <Suspense fallback={<LoadingCard />}>
              <CachedPostCard />
            </Suspense>
          </div>
        </div>

        <p className="text-sm text-gray-600 dark:text-gray-400 mt-4">
          üí° <strong>Tip:</strong> Refresh the page multiple times. The uncached card
          updates on every refresh, while the cached card stays the same until revalidated.
        </p>
      </section>

      {/* Tagged cache demo */}
      <section>
        <h3 className="text-xl font-semibold mb-4">Cache Tags & On-Demand Revalidation</h3>
        <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
          Tag cached requests for targeted invalidation. Click buttons below to revalidate specific tags.
        </p>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <Suspense fallback={<LoadingCard />}>
            <TaggedPostCard postId={1} tag="post-1" />
          </Suspense>
          <Suspense fallback={<LoadingCard />}>
            <TaggedPostCard postId={2} tag="post-2" />
          </Suspense>
          <Suspense fallback={<LoadingCard />}>
            <TaggedPostCard postId={3} tag="posts" />
          </Suspense>
        </div>

        {/* Revalidation buttons */}
        <div className="flex flex-wrap gap-3">
          <RevalidateButton tag="post-1" label="Revalidate Post 1" />
          <RevalidateButton tag="post-2" label="Revalidate Post 2" />
          <RevalidateButton tag="posts" label="Revalidate All Posts" />
        </div>
      </section>

      {/* Time-based revalidation */}
      <section>
        <h3 className="text-xl font-semibold mb-4">Time-Based Revalidation (ISR)</h3>
        <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
          Set automatic revalidation intervals. Data refreshes in background after specified time.
        </p>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <Suspense fallback={<LoadingCard />}>
            <RevalidatingCard seconds={10} label="Every 10s" />
          </Suspense>
          <Suspense fallback={<LoadingCard />}>
            <RevalidatingCard seconds={30} label="Every 30s" />
          </Suspense>
          <Suspense fallback={<LoadingCard />}>
            <RevalidatingCard seconds={60} label="Every 60s" />
          </Suspense>
        </div>
      </section>

      {/* Technical details */}
      <section className="p-6 border border-gray-200 dark:border-gray-800 rounded-lg">
        <h3 className="text-xl font-semibold mb-3">How It Works</h3>
        <div className="space-y-4 text-sm">
          <div>
            <h4 className="font-semibold mb-1">1. First Request (MISS)</h4>
            <p className="text-gray-600 dark:text-gray-400">
              fetch() ‚Üí Network request ‚Üí Store in Data Cache ‚Üí Return data
            </p>
          </div>
          <div>
            <h4 className="font-semibold mb-1">2. Subsequent Requests (HIT)</h4>
            <p className="text-gray-600 dark:text-gray-400">
              fetch() ‚Üí Check Data Cache ‚Üí Return cached data ‚Üí No network request
            </p>
          </div>
          <div>
            <h4 className="font-semibold mb-1">3. After Revalidation</h4>
            <p className="text-gray-600 dark:text-gray-400">
              revalidateTag() ‚Üí Mark stale ‚Üí Next fetch() refreshes cache ‚Üí Background update
            </p>
          </div>
        </div>
      </section>
    </div>
  );
}

// Loading placeholder
function LoadingCard() {
  return (
    <div className="p-4 border border-gray-200 dark:border-gray-800 rounded-lg animate-pulse">
      <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-3"></div>
      <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-full mb-2"></div>
      <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-5/6"></div>
    </div>
  );
}

// Uncached fetch - always fresh
async function UncachedPostCard() {
  // Timestamp when component starts rendering
  const renderTime = new Date().toISOString();

  // Fetch WITHOUT caching (default in Next.js 16)
  const post = await fetch('https://jsonplaceholder.typicode.com/posts/1', {
    cache: 'no-store', // Explicitly opt out of Data Cache
  }).then((res) => res.json());

  // Extract timestamp from response (we'll add this to API later)
  const fetchTime = new Date().toISOString();

  return (
    <div className="p-4 border border-red-200 dark:border-red-800 rounded-lg">
      <div className="flex items-center justify-between mb-3">
        <span className="text-xs px-2 py-1 rounded bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200">
          UNCACHED
        </span>
      </div>

      <h4 className="font-semibold mb-2">{post.title}</h4>
      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
        {post.body.substring(0, 100)}...
      </p>

      <div className="space-y-1 text-xs text-gray-500 pt-3 border-t border-gray-200 dark:border-gray-700">
        <p>Rendered: {renderTime}</p>
        <p>Fetched: {fetchTime}</p>
        <p className="text-red-600 dark:text-red-400">
          ‚úó Always makes network request
        </p>
      </div>
    </div>
  );
}

// Cached fetch - persists across requests
async function CachedPostCard() {
  const renderTime = new Date().toISOString();

  // Fetch WITH caching (opt-in via force-cache)
  const post = await fetch('https://jsonplaceholder.typicode.com/posts/2', {
    cache: 'force-cache', // Opt into Data Cache - cached indefinitely
  }).then((res) => res.json());

  const fetchTime = new Date().toISOString();

  return (
    <div className="p-4 border border-green-200 dark:border-green-800 rounded-lg">
      <div className="flex items-center justify-between mb-3">
        <span className="text-xs px-2 py-1 rounded bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200">
          CACHED
        </span>
      </div>

      <h4 className="font-semibold mb-2">{post.title}</h4>
      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
        {post.body.substring(0, 100)}...
      </p>

      <div className="space-y-1 text-xs text-gray-500 pt-3 border-t border-gray-200 dark:border-gray-700">
        <p>Rendered: {renderTime}</p>
        <p>Cached: {fetchTime}</p>
        <p className="text-green-600 dark:text-green-400">
          ‚úì Served from Data Cache
        </p>
      </div>
    </div>
  );
}

// Tagged fetch - can be revalidated by tag
async function TaggedPostCard({ postId, tag }: { postId: number; tag: string }) {
  const renderTime = new Date().toISOString();

  // Fetch with cache tag for targeted revalidation
  const post = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${postId}`,
    {
      // Cache forever, revalidate only when tag is triggered
      cache: 'force-cache',
      next: {
        tags: [tag], // Tag this cache entry for invalidation
      },
    }
  ).then((res) => res.json());

  return (
    <div className="p-4 border border-blue-200 dark:border-blue-800 rounded-lg">
      <div className="flex items-center justify-between mb-3">
        <span className="text-xs px-2 py-1 rounded bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200">
          TAG: {tag}
        </span>
      </div>

      <h4 className="font-semibold mb-2 text-sm">{post.title}</h4>
      <p className="text-xs text-gray-600 dark:text-gray-400 mb-3">
        {post.body.substring(0, 80)}...
      </p>

      <div className="space-y-1 text-xs text-gray-500 pt-2 border-t border-gray-200 dark:border-gray-700">
        <p>Cached: {renderTime}</p>
        <p className="text-blue-600 dark:text-blue-400">
          ‚úì Tagged for revalidation
        </p>
      </div>
    </div>
  );
}

// Time-based revalidation (ISR pattern)
async function RevalidatingCard({
  seconds,
  label,
}: {
  seconds: number;
  label: string;
}) {
  const renderTime = new Date().toISOString();

  // Fetch with time-based revalidation
  // After {seconds}, cache becomes stale and revalidates on next request
  const post = await fetch('https://jsonplaceholder.typicode.com/posts/4', {
    next: {
      revalidate: seconds, // Revalidate after X seconds (stale-while-revalidate)
    },
  }).then((res) => res.json());

  return (
    <div className="p-4 border border-purple-200 dark:border-purple-800 rounded-lg">
      <div className="flex items-center justify-between mb-3">
        <span className="text-xs px-2 py-1 rounded bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200">
          {label}
        </span>
      </div>

      <h4 className="font-semibold mb-2 text-sm">{post.title}</h4>
      <p className="text-xs text-gray-600 dark:text-gray-400 mb-3">
        {post.body.substring(0, 80)}...
      </p>

      <div className="space-y-1 text-xs text-gray-500 pt-2 border-t border-gray-200 dark:border-gray-700">
        <p>Cached: {renderTime}</p>
        <p className="text-purple-600 dark:text-purple-400">
          ‚è± Revalidates every {seconds}s
        </p>
      </div>
    </div>
  );
}
```

---

### Step 2: Create Revalidation Button Component

**Location:** `my-app/app/(dashboard)/data-cache/components/RevalidateButton.tsx`

**Action:** Client component for triggering revalidation

```typescript
'use client';

import { useState } from 'react';
import { revalidateTagAction } from '@/app/actions/cache-actions';

/**
 * Client component that triggers Server Action to revalidate cache tag
 * Shows loading state and timestamp of last revalidation
 */
export function RevalidateButton({ tag, label }: { tag: string; label: string }) {
  const [isRevalidating, setIsRevalidating] = useState(false);
  const [lastRevalidated, setLastRevalidated] = useState<string | null>(null);

  const handleRevalidate = async () => {
    setIsRevalidating(true);

    try {
      // Call Server Action to revalidate tag
      await revalidateTagAction(tag);

      // Update timestamp on success
      setLastRevalidated(new Date().toLocaleTimeString());
    } catch (error) {
      console.error('Revalidation failed:', error);
    } finally {
      setIsRevalidating(false);
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <button
        onClick={handleRevalidate}
        disabled={isRevalidating}
        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white rounded-md text-sm transition-colors"
      >
        {isRevalidating ? 'Revalidating...' : label}
      </button>

      {lastRevalidated && (
        <p className="text-xs text-gray-500">
          Last revalidated: {lastRevalidated}
        </p>
      )}
    </div>
  );
}
```

---

### Step 3: Implement Server Actions for Revalidation

**Location:** `my-app/app/actions/cache-actions.ts` (update)

**Action:** Add revalidateTag implementation

```typescript
'use server';

// Server Actions for cache invalidation
import { revalidatePath } from 'next/cache';
import { revalidateTag } from 'next/cache';

/**
 * Revalidates all cache entries with specific tag
 * Uses stale-while-revalidate strategy (users see stale content while fresh loads)
 *
 * @param tag - Cache tag to revalidate (e.g., 'post-1', 'posts')
 */
export async function revalidateTagAction(tag: string) {
  console.log(`[Cache Action] Revalidating tag: ${tag} at ${new Date().toISOString()}`);

  try {
    // Revalidate with 'max' profile for stale-while-revalidate behavior
    // Users see old content while new content fetches in background
    revalidateTag(tag, 'max');

    return { success: true, tag };
  } catch (error) {
    console.error(`Failed to revalidate tag ${tag}:`, error);
    throw error;
  }
}

/**
 * Revalidates a specific path, clearing Data Cache + Full Route Cache
 *
 * @param path - Path to revalidate (e.g., '/data-cache', '/profile')
 */
export async function revalidatePathAction(path: string) {
  console.log(`[Cache Action] Revalidating path: ${path} at ${new Date().toISOString()}`);

  try {
    revalidatePath(path);
    return { success: true, path };
  } catch (error) {
    console.error(`Failed to revalidate path ${path}:`, error);
    throw error;
  }
}

// updateTagAction will be implemented in Plan 07 (Invalidation)
export async function updateTagAction(tag: string) {
  // Implementation in Plan 07
}
```

---

### Step 4: Add Stale-While-Revalidate Visualization

**Location:** `my-app/app/(dashboard)/data-cache/components/RevalidationStatus.tsx`

**Action:** Component showing cache lifecycle

```typescript
'use client';

import { useEffect, useState } from 'react';

/**
 * Visualizes the cache lifecycle after revalidation
 * Shows: Fresh ‚Üí Stale ‚Üí Revalidating ‚Üí Fresh
 */
export function RevalidationStatus({ revalidateSeconds }: { revalidateSeconds: number }) {
  const [status, setStatus] = useState<'fresh' | 'stale' | 'revalidating'>('fresh');
  const [timeLeft, setTimeLeft] = useState(revalidateSeconds);

  useEffect(() => {
    // Countdown timer
    const interval = setInterval(() => {
      setTimeLeft((prev) => {
        if (prev <= 1) {
          setStatus('stale');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  const statusColors = {
    fresh: 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border-green-200 dark:border-green-800',
    stale: 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 border-yellow-200 dark:border-yellow-800',
    revalidating: 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 border-blue-200 dark:border-blue-800',
  };

  return (
    <div className={`p-3 border rounded-md ${statusColors[status]}`}>
      <div className="flex items-center justify-between text-sm">
        <span className="font-semibold">
          Status: {status.toUpperCase()}
        </span>
        {status === 'fresh' && (
          <span>Revalidates in {timeLeft}s</span>
        )}
      </div>
    </div>
  );
}
```

---

## Expected Result After Completion

### What You Should See

1. **Cached vs Uncached Comparison:**
   - Uncached card: Timestamp updates on every refresh
   - Cached card: Timestamp stays the same across refreshes

2. **Tagged Cache Section:**
   - 3 cards with different tags (post-1, post-2, posts)
   - Revalidate buttons below cards
   - Clicking button refreshes only that tagged card

3. **Time-Based Revalidation:**
   - 3 cards with different intervals (10s, 30s, 60s)
   - After interval passes + page refresh, new data loads

4. **Network Tab:**
   - Cached requests: No network call on refresh
   - Uncached requests: Network call every time

### Behavior After Revalidation

1. Click "Revalidate Post 1" button
2. Refresh the page
3. Post 1 card shows updated timestamp
4. Other cards remain unchanged

---

## Testing Steps

### 1. Test Cached vs Uncached

1. Visit `/data-cache`
2. Note timestamps on both cards
3. Refresh page (Cmd+R / Ctrl+R)
4. **Expected:**
   - Uncached card: New timestamp
   - Cached card: Same timestamp

### 2. Test Cache Tags

1. Note timestamp on "Post 1" card
2. Click "Revalidate Post 1" button
3. Wait for "Last revalidated" message
4. Refresh page
5. **Expected:** Post 1 has new timestamp, others unchanged

### 3. Test Time-Based Revalidation

1. Note timestamp on "Every 10s" card
2. Wait 11+ seconds
3. Refresh page
4. **Expected:** New timestamp on that card

### 4. Check Network Tab

1. Open DevTools ‚Üí Network ‚Üí Filter "jsonplaceholder"
2. Refresh page
3. **Expected:**
   - Cached requests: 0 network calls
   - Uncached requests: 1 network call

### 5. Check Server Console

Look for revalidation logs:
```
[Cache Action] Revalidating tag: post-1 at 2025-11-10T...
```

---

## Key Concepts Learned

1. **Opt-In Caching (v16):** Must explicitly use `{ cache: 'force-cache' }`
2. **Cache Tags:** Tag requests for targeted invalidation
3. **Time-Based Revalidation:** ISR pattern with `{ next: { revalidate: seconds } }`
4. **Stale-While-Revalidate:** Serve old content while fetching fresh
5. **On-Demand Revalidation:** `revalidateTag()` for immediate updates
6. **Persistence:** Data Cache survives across requests/users until invalidated

---

## Next Steps

- ‚úÖ Data Cache demo complete
- ‚è≠Ô∏è **Plan 04:** Implement Full Route Cache demo

---

**Status:** Ready for implementation
**Dependencies:** Plan 01 (setup) must be completed
**Estimated Time:** 40-50 minutes
